
/**
 * The Algorithm class contains recursive methods for several algorithmic problems.
 * <p>
 * It includes methods to compute factorial, count bunny ears, calculate Fibonacci numbers,
 * sum the digits of a number, count occurrences of the digit 8 (with special counting rules),
 * and compute exponentiation recursively.
 * </p>
 * 
 * How to compile and run the application:
 * 1. Open a terminal or command prompt.
 * 2. Compile: 
 *      `javac std02-arron-algo/AlgorithmAPSecond.java`
 * 3. Run: 
 *      `java -cp std02-arron-algo AlgorithmAPSecond`
 * 4. Clean: 
 *      `rm -rf std02-arron-algo/*.class`
 */
import java.util.Arrays;
import java.util.ArrayList;
import java.util.List;


public class AlgorithmAPSecond {
    /**
     * < Q00 >
     * This is a placeholder for the main method. It can be used to 
     * test the methods in this class.
     * You can add your own test cases here.
     *
     * @param args command line arguments (not used).
     */
    public static void main(String[] args) {
        System.out.println("Hello, World!");
    }






    


    /**
     * < Q10 >
     * Given an array of positive integers, return a new array containing 
     * the first {@code count} even numbers from the original array.
     * The original array will contain at least {@code count} even numbers.
     *
     * @param nums  an array of positive integers
     * @param count the number of even integers to return
     * @return an array of the first {@code count} even integers from the original array
     *
     * <p>
     * Examples:
     * <ul>
     *   <li>copyEvens(new int[]{3, 2, 4, 5, 8}, 2) returns [2, 4]</li>
     *   <li>copyEvens(new int[]{3, 2, 4, 5, 8}, 3) returns [2, 4, 8]</li>
     *   <li>copyEvens(new int[]{6, 1, 2, 4, 5, 8}, 3) returns [6, 2, 4]</li>
     * </ul>
     * </p>
     */
    public static int[] copyEvens(int[] nums, int count) {
        int[] result = new int[count];
        // [Your Implementation Here]
        //
        // Case-1. If the question can be solved with 'iteration (for/while)',
        //         design the most efficient algorithm.
        //
        // Case-2. If the question can be solved with 'recursion', design a
        //         correct algorithm. Since the recursion can be inefficient,
        //         use either 'tabulation' or 'memorization' to break it down
        //         into 'iteration'.
        return result;
    }





    // Q11 comming soon..!
}
